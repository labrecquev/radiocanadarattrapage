import requests
from bs4 import BeautifulSoup
import dateparser
import os
from datetime import datetime, timedelta
import re
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import ast


def lambda_handler(event, context):
    now = datetime.now()
    now = now - timedelta(days=1) # simulate today as being yesterday for debugging
    today = now.date()
    yesterday = today - timedelta(days=1)

    def main():
        global radio_shows_dict, rattrapage_data, email_summary
        start = datetime.now()
        print(f"Script start, retrieving {today}'s shows. It is {datetime.now()}")
        
        # get credentials and email info
        pwd = os.getenv('MY_PASSWORD')
        mail_user = os.getenv('MAIL_USER')
        mail_list = os.getenv('MAIL_LIST')
        radio_shows_url = "https://ici.radio-canada.ca/ohdio/premiere/emissions/?regionIds=8"

        # main functions
        radio_shows_dict = get_radio_shows(radio_shows_url)
        rattrapage_data = get_rattrapage_data(radio_shows_dict)

        if not rattrapage_data:
            print("No rattrapage data found, stopping script.")
            return
        
        email_summary = build_email_summary(rattrapage_data)
        send_email_summary(email_summary, mail_user, mail_list, pwd)
        
        duration = datetime.now() - start
        
        print(f"Script done, it took {duration}")
        
    def get_radio_shows(url):
        response = requests.get(url)
        radio_shows_dict = {}
        
        if response.status_code != 200:
            print(f"\tFailed to retrieve HTML: {response.status_code}")
            return radio_shows_dict

        print("Radio shows' HTML read successfully. Building a dictionary..")        
        soup = BeautifulSoup(response.text, 'html.parser')        
        radio_shows = soup.find('ol', class_='index-grid-list')

        if not radio_shows:
            print("No radio shows found.")
            return radio_shows_dict
        
        for li in radio_shows.find_all('li'):
            a_tag = li.find('a')
            if not a_tag:
                print("no radio show url, next show")
                continue
            href = a_tag.get('href')
            show_name = a_tag.find('span').text
            url = f"https://ici.radio-canada.ca{href}"
            radio_shows_dict[show_name] = url
        return radio_shows_dict
            
    def french_date_parser(string):
        replacements = {'janv.':'janvier', 'févr.':'février', 'fév.':'février', 'avr.':'avril',
                        'juill.':'juillet', 'sept.':'septembre', 'oct.':'octobre', 'nov.':'novembre',
                        'déc.':'décembre'}
        # Define the regex pattern for French dates
        pattern = r'\b([1-9]|[12][0-9]|3[01])\w*\s(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre|janv.|févr.|avr.|juill.|sept.|oct.|nov.|déc.)\s(\d{4})\b'

        match = re.search(pattern, string, re.IGNORECASE)

        if not match:
            print(f"Could not parse date from:\n{string}")
            return None

        raw_date = match.group()

        for month_abbrv, fullmonthname in replacements.items():
            raw_date = raw_date.replace(month_abbrv, fullmonthname)

        parsed_date = dateparser.parse(raw_date)

        if not parsed_date:
            print(f"Could not parse date from: {string}")
            return None
        
        return parsed_date            
        
    def get_rattrapage_data(radio_shows_dict):
        rattrapage_data = {}
        
        for name, url in radio_shows_dict.items():
            print(f"\n{name}\n\t{url}")
            
            response = requests.get(url)
            
            if not response.status_code == 200:
                print(f"\tFailed to retrieve HTML: {response.status_code}")
                continue
            
            print("\tHTML read successfully")
            response = response.text                
        
            soup = BeautifulSoup(response, 'html.parser')
            
            emissions = soup.find('ul', class_='list-cue')
            
            if not emissions:
                print("\tno rattrapage, next show")
                continue
        
            li_items = emissions.find_all('li')
            yesterday_data = None # init variable

            for li in li_items:

                h_tag = li.find('h2')
                if not h_tag:
                    print("\tno header, next broadcast")
                    continue
                a_tag = li.find('a')
                
                if not a_tag:
                    print("\tno url, next broadcast")
                    continue
                
                href = a_tag.get('href')
                emission_url = f"https://ici.radio-canada.ca{href}"

                link_text = a_tag.text.strip()

                try:
                    print(f"\tTrying to parse date from: {link_text}")
                    parsed_date = french_date_parser(link_text)
                    print(f"\t{parsed_date}'s show date parsed")
                except Exception as e:
                    print(f"\t\t{e}")
                    continue

                if not parsed_date:
                    print("\tno date parsed, next broadcast")
                    continue

                parsed_day = parsed_date.date()

                try:
                    text_subtitle = li.find('span', class_='text summary')
                    text_subtitle = text_subtitle.text.strip()
                    show_segments = text_subtitle.split(';')
                except Exception as e:
                    print("\tCould not get show segments, next broadcast")
                    continue

                if not text_subtitle:
                    print("\tno show summary, next broadcast")
                    continue
                
                # Check if it's today's show
                if parsed_day == today:
                    print(f"\tFound today's show. Inserting {parsed_day}'s show into dict")
                    rattrapage_data[name] = [emission_url, show_segments, parsed_day]
                    break  # Stop looping - we found today's show
                
                # Check if it's yesterday's show
                elif parsed_day == yesterday:
                    print(f"\tFound yesterday's show, storing tentatively")
                    yesterday_data = [emission_url, show_segments, parsed_day]
                    # Continue looping in case we find today's show
                
                else:
                    print("\tparsed date not today or yesterday, continue")
                    continue
                
            if name not in rattrapage_data and yesterday_data:
                print(f"\tNo today's show found, using yesterday's show")
                rattrapage_data[name] = yesterday_data
                
        return rattrapage_data

    def build_email_summary(rattrapage_data):
        print("\nBuilding email summary")
        # Initialize an empty string to hold the HTML content
        html_content = "<ul>\n"
        
        # Iterate over the dictionary to build the HTML list
        for name, (url, show_segments, date) in rattrapage_data.items():
            html_content += "  <li>\n"
            html_content += f"    <a href='{url}'>{name}, {date}</a>\n"
            html_content += "    <ul>\n"
            for show_segment in show_segments:
                html_content += f"      <li>{show_segment}</li>\n"
            html_content += "    </ul>\n"
            html_content += "  </li>\n"
        
        # Close the unordered list tag
        html_content += "</ul>"
        return html_content
    
    def send_email_summary(email_summary, mail_user, mail_list, pwd):     
        print("\nSending email summary")
        # Email parameters
        sent_from = mail_user
        # sent_to = ', '.join(ast.literal_eval(mail_list))
        sent_to = ast.literal_eval(mail_list)
        subject = f"Rattrapage Radio-Canada du {now.date()}"
        
        # Create the MIME message
        msg = MIMEMultipart('alternative')
        msg['Subject'] = subject
        msg['From'] = sent_from
        msg['To'] = ', '.join(sent_to)        
        
        # Attach the HTML content
        html_part = MIMEText(email_summary, 'html')
        msg.attach(html_part)
        
        # Send the email using SMTP
        try:
            server = smtplib.SMTP_SSL('mail.labrecquev.ca', 465)
            server.ehlo()
            server.login(mail_user, pwd)
            server.sendmail(sent_from, sent_to, msg.as_string())
            server.quit()
            print("Email sent!")
        except Exception as error:
            print(f"Email not sent\n{error=}")

    main()

if __name__ == "__main__":
    from dotenv import load_dotenv
    from pathlib import Path
    env_path = Path(__file__).parent / ".env"
    load_dotenv(dotenv_path=env_path)

    lambda_handler(None,None)