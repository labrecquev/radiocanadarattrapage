import requests
from bs4 import BeautifulSoup
import dateparser
import os
from datetime import datetime, timedelta
import re
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import ast
    
def get_radio_shows(url):
    response = requests.get(url)
    radio_shows_dict = {}
    
    if not response.status_code == 200:
        print(f"\tFailed to retrieve HTML: {response.status_code}")
        return radio_shows_dict

    print("Radio shows' HTML read successfully. Building a dictionary..")        
    soup = BeautifulSoup(response.text, 'html.parser')        
    radio_shows = soup.find('ol', class_='index-grid-list')

    if not radio_shows:
        print("No radio shows found.")
        return radio_shows_dict
    
    for li in radio_shows.find_all('li'):
        a_tag = li.find('a')
        if not a_tag:
            print("no radio show url, next show")
            continue
        href = a_tag.get('href')
        show_name = a_tag.find('span').text
        url = f"https://ici.radio-canada.ca{href}"
        radio_shows_dict[show_name] = url
    return radio_shows_dict
        
def french_date_parser(string):
    print(f"\tTrying to parse date from: {string}")
    replacements = {'janv.':'janvier', 'févr.':'février', 'fév.':'février', 'avr.':'avril',
                    'juill.':'juillet', 'sept.':'septembre', 'oct.':'octobre', 'nov.':'novembre',
                    'déc.':'décembre'}
    # Define the regex pattern for French dates
    pattern = r'\b([1-9]|[12][0-9]|3[01])\w*\s(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre|janv.|févr.|avr.|juill.|sept.|oct.|nov.|déc.)\s(\d{4})\b'

    match = re.search(pattern, string, re.IGNORECASE)

    if not match:
        print(f"\tCould not parse date from:\n{string}")
        return None

    raw_date = match.group()

    for month_abbrv, fullmonthname in replacements.items():
        raw_date = raw_date.replace(month_abbrv, fullmonthname)

    parsed_date = dateparser.parse(raw_date)

    if not parsed_date:
        print(f"\tCould not parse date from: {string}")
        return None
    
    print(f"\tSucessfully parsed {parsed_date}")
    return parsed_date            
    
def get_rattrapage_data(radio_shows_dict, today, yesterday, testing):
    rattrapage_data = {}
    
    for name, url in radio_shows_dict.items():
        print(f"\n{name}\n\t{url}")        
        response = requests.get(url)
        
        if not response.status_code == 200:
            print(f"\tFailed to retrieve HTML: {response.status_code}")
            continue
        
        print("\tHTML read successfully")
        soup = BeautifulSoup(response.text, 'html.parser')        
        emissions = soup.find('ul', class_='list-cue')
        
        if not emissions:
            print("\tno rattrapage, next show")
            continue

        yesterday_data = None # init variable

        for li in emissions.find_all('li'):
            h_tag = li.find('h2')
            a_tag = li.find('a')
            if not (h_tag and a_tag):
                print("\tno header or url, next broadcast")
                continue
            
            emission_url = f"https://ici.radio-canada.ca{a_tag.get('href')}"
            link_text = a_tag.text.strip()

            parsed_date = french_date_parser(link_text)

            if not parsed_date:                
                continue

            parsed_day = parsed_date.date()

            text_subtitle = li.find('span', class_='text summary')

            if not text_subtitle:
                print("\tCould not get summary, next broadcast")
                continue

            show_segments = text_subtitle.text.strip().split(';')

            if parsed_day == today: # Check if it's today's show
                print(f"\tFound today's show. Inserting {parsed_day}'s show into dict")
                rattrapage_data[name] = [emission_url, show_segments, parsed_day]
                break  # Stop looping - we found today's show
            
            elif parsed_day == yesterday: # Check if it's yesterday's show
                print(f"\tFound yesterday's show, storing tentatively")
                yesterday_data = [emission_url, show_segments, parsed_day]
                # Continue looping in case we find today's show

        if name not in rattrapage_data and yesterday_data and today.weekday() < 5:
            print(f"\tNo today's show found, using yesterday's show")
            rattrapage_data[name] = yesterday_data
        
        if testing and rattrapage_data:
            break

    return rattrapage_data

def build_email_summary(rattrapage_data):
    print("\nBuilding email summary")    
    html_content = "<ul>\n" # Initialize an empty string to hold the HTML content
    
    # Iterate over the dictionary to build the HTML list
    for name, (url, show_segments, date) in rattrapage_data.items():
        html_content += f"  <li><a href='{url}'>{name}, {date}</a><ul>\n"
        for segment in show_segments:
            html_content += f"    <li>{segment}</li>\n"
        html_content += "    </ul></li>\n"

    html_content += "</ul>" # Close the unordered list tag
    return html_content

def send_email_summary(email_summary, mail_user, mail_list, pwd, subject_date):     
    print("\nSending email summary")
    # Email parameters
    sent_to = ast.literal_eval(mail_list)

    # Create the MIME message
    msg = MIMEMultipart('alternative')
    msg['Subject'] = f"Rattrapage Radio-Canada du {subject_date}"
    msg['From'] = mail_user
    msg['To'] = ', '.join(sent_to)
    
    # Attach the HTML content
    html_part = MIMEText(email_summary, 'html')
    msg.attach(html_part)
    
    # Send the email using SMTP
    try:
        server = smtplib.SMTP_SSL('mail.labrecquev.ca', 465)
        server.ehlo()
        server.login(mail_user, pwd)
        server.sendmail(mail_user, sent_to, msg.as_string())
        server.quit()
        print("Email sent!")
    except Exception as e:
        print(f"Email not sent\n{e}")

def main():    
    testing = False
    now = datetime.now() - timedelta(days=1) if testing else datetime.now()
    today = now.date()
    yesterday = today - timedelta(days=1)

    start = datetime.now()
    print(f"Script start, retrieving {today}'s shows. It is {datetime.now()}")
    
    # get credentials and email info
    pwd = os.getenv('MY_PASSWORD')
    mail_user = os.getenv('MAIL_USER')
    mail_list = os.getenv('MAIL_LIST')

    radio_shows_url = "https://ici.radio-canada.ca/ohdio/premiere/emissions/?regionIds=8"

    # main functions
    radio_shows = get_radio_shows(radio_shows_url)
    rattrapage_data = get_rattrapage_data(radio_shows, today, yesterday, testing)

    if not rattrapage_data:
        print("No rattrapage data found, stopping script.")
        return
    
    email_summary = build_email_summary(rattrapage_data)
    send_email_summary(email_summary, mail_user, mail_list, pwd, today)
    
    print(f"Script done, it took {datetime.now() - start}")

def lambda_handler(event, context):
    main()

if __name__ == "__main__":
    from dotenv import load_dotenv
    from pathlib import Path
    env_path = Path(__file__).parent / ".env"
    load_dotenv(dotenv_path=env_path)

    lambda_handler(None,None)